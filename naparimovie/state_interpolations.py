"""
This module implements helper functions to calculate interpolated states
between successive napari views states
"""
# Author: Guillaume Witz, Science IT Support, Bern University, 2019
# License: BSD3 License

import copy, re
import numpy as np
from pyquaternion import Quaternion as pyQuaternion
from vispy.util.quaternion import Quaternion

def interpolate(states_dict):
    """Calculate interpolations for all states
        
    Returns
    -------
    interpolated: dict
        dictionary defining interpolated states. Each element is a list of length N
        frames. Keys are:
            'rotate': list of pyquaternions
            'translate': list of tuple defining camera center
            'zoom': list of floats defining camera zoom
            'vis': list of boolean lists defining layer visibility
            'time': list of int defining time-point
    """
    
    
    interpolated = {}
    interpolated['rotate'] = interpolate_rotation(states_dict)
    interpolated['translate'] = interpolate_translation(states_dict)
    interpolated['zoom'] = interpolate_scales(states_dict)
    interpolated['vis'] = interpolate_visibility(states_dict)
    interpolated['time'] = interpolate_time(states_dict)
    
    return interpolated
    
    
def interpolate_rotation(states_dict):
    """Interpolate rotation states as quaternions
    
    Parameters
    ----------
    states_dict: list of dicts
        list of states dictionaries generated by scriptcommands.create_frame_commandlist()
        and naparimovie.create_state_dict()
    
    Returns
    -------
    all_states: list of pyquaternions
        list of rotation states of length N frames
            
    """
    
    frames_rot = [[x['frame'], x['rotate']] for x in states_dict if x['rotate']]
    
    all_states = {x: [] for x in range(frames_rot[0][0],frames_rot[-1][0]+1)}

    for i in range(len(frames_rot)-1):
        q0 = pyQuaternion(frames_rot[i][1].w, frames_rot[i][1].x,
                          frames_rot[i][1].y,frames_rot[i][1].z)
        q1 = pyQuaternion(frames_rot[i+1][1].w, frames_rot[i+1][1].x,
                          frames_rot[i+1][1].y,frames_rot[i+1][1].z)

        num_frames = frames_rot[i+1][0]-frames_rot[i][0]-1
        for ind, q in enumerate(pyQuaternion.intermediates(q0, q1,num_frames, include_endpoints=True)):
            all_states[frames_rot[i][0]+ind] =  q
    all_states = [all_states[x] for x in all_states.keys()]
    return all_states


def interpolate_translation(states_dict):
    """Interpolate camera center views
    
    Parameters
    ----------
    states_dict: list of dicts
        list of states dictionaries generated by scriptcommands.create_frame_commandlist()
        and naparimovie.create_state_dict()
    
    Returns
    -------
    center_interp: list of tuples
        list of tuples defining camera center view of length N frames
            
    """
    
    frames_trans = np.array([np.concatenate(([x['frame']], np.array(x['translate']))) 
                         for x in states_dict if x['translate']])
    all_frames = np.array([x['frame'] for x in states_dict])

    center_interp = [np.interp(x=all_frames,xp = frames_trans[:,0], 
                                   fp = frames_trans[:,c+1]) for c in range(3)]
    center_interp = np.stack(center_interp,axis = 1)
    center_interp = [tuple(x) for x in center_interp]

    return center_interp


def interpolate_scales(states_dict):
    """Interpolate camera zoom states
    
    Parameters
    ----------
    states_dict: list of dicts
        list of states dictionaries generated by scriptcommands.create_frame_commandlist()
        and naparimovie.create_state_dict()
    
    Returns
    -------
    scales_interp: list of floats
        list of floats defining camera zoom of length N frames
            
    """
    
    frames = [x['frame'] for x in states_dict]
    all_scales = np.array([[x['frame'], x['zoom']] for x in states_dict if x['zoom']])
    scales_interp = np.interp(x=frames,xp = all_scales[:,0], fp = all_scales[:,1])
    
    return scales_interp

def interpolate_visibility(states_dict):
    """Interpolate visibility states of layers
    
    Parameters
    ----------
    states_dict: list of dicts
        list of states dictionaries generated by scriptcommands.create_frame_commandlist()
        and naparimovie.create_state_dict()
    
    Returns
    -------
    frame_make: list of lists
        list of lists defining layer visibility of length N frames. e.g. [[True, False],[True, False]....]
        for 2 layers
            
    """
    
    frame_make = np.array([np.concatenate(([x['frame']], x['vis'])) for x in states_dict if x['vis']])
    frame_make = np.concatenate([[frame_make[x,1::] for i in range(frame_make[x,0],frame_make[x+1,0])] 
                for x in range(len(frame_make)-1)]+[[frame_make[-1,1::]]]).astype(bool)
    return frame_make

def interpolate_time(states_dict):
    """Interpolate time frames for 4D data
    
    Parameters
    ----------
    states_dict: list of dicts
        list of states dictionaries generated by scriptcommands.create_frame_commandlist()
        and naparimovie.create_state_dict()
    
    Returns
    -------
    time_interp: list of ints
        list of time points of length N frames.
            
    """
    
    frames = [x['frame'] for x in states_dict]
    all_scales = np.array([[x['frame'], x['time']] for x in states_dict if type(x['time']) is not list])
    time_interp = None
    if len(all_scales)>0:
        time_interp = np.interp(x=frames,xp = all_scales[:,0], fp = all_scales[:,1]).astype(int)
    
    return time_interp














